Model SysADLModel ; package SysADL.types { value type Int { } value type Boolean { }   value type Real { }            enum ComandoCancela { Abrir , Fechar , Manter }  value type Hora { } datatype Ticket { attributes : pago : Boolean ; id : String ; entrada : Hora ; valor : Real ; data : Data ; } datatype VagasDisponiveis { attributes : tipo : TipoVaga ; quantidade : Int ; } value type String { } enum TipoVaga { Normal , Idoso , Deficiente , Gestante } enum FormasPagamento { PIX , Debito , Credito } enum StatusPresenca { Ocupado , Desocupado , Desabilitado } datatype PresencaVaga { attributes : tipo : TipoVaga ; status : StatusPresenca ; } enum Lotacao { Lotado , Vago } value type Data { } datatype Pagamento { attributes : ticket : Ticket ; forma : FormasPagamento ; DadosPagamento : Any ; } value type Any { } } package ParkingSystemConnectors { import ParkingSystemPorts ; connector def DetectarPresencaCN { participants : ~ dpOPT : PresencaOPT ; ~ dpIPT : PresencaIPT ; ~ sDPresOPT : StatusOPT ; ~ sDPreIPT : StatusIPT ; flows : Boolean from sDPresOPT to sDPreIPT  PresencaVaga from dpOPT to dpIPT }   connector def AcionarCancelaCN { participants : ~ acOPT : CancelaOPT ; ~ acIPT : CancelaIPT ; flows : ComandoCancela from acOPT to acIPT }  connector def TicketCN { participants : ~ pOPT : TicketOPT ; ~ pIPT : TicketIPT ; flows : Ticket from pOPT to pIPT }  connector def MonitorarVagasCN { participants : ~ mvOPT : QuantidadeDeVagasOPT ; ~ mvIPT : QuantidadeDeVagasIPT ; flows :  VagasDisponiveis from mvOPT to mvIPT } connector def DetectarPassagemCN { participants :   ~ dpasCOPT : CancelaOPT ;  ~ dpasCIPT : CancelaIPT ; ~ sDPasOPT : StatusOPT ; ~ sDPasIPT : StatusIPT ; flows : ComandoCancela from dpasCOPT to dpasCIPT Boolean from sDPasOPT to sDPasIPT } connector def ErroPagamentoCN { participants : ~ epOPT : ErroPagamentoOPT ; ~ epIPT : ErroPagamentoIPT ; flows : Boolean from epOPT to epIPT } connector def PresencaCN { participants : ~ pPOPT : PresencaOPT ; ~ pPIPT : PresencaIPT ; flows : PresencaVaga from pPOPT to pPIPT } connector def LotacaoCN { participants : ~ lLOPT : LotacaoOPT ; ~ lLIPT : LotacaoIPT ; flows : Lotacao from lLOPT to lLIPT } connector def SolicitacaoCN { participants : ~ sSOPT : SolicitarOPT ; ~ sSIPT : SolicitarIPT ; flows : Boolean from sSOPT to sSIPT } connector def DadoTicketCN { participants : ~ dtDTOPT : DadoTicketOPT ; ~ dtDTIPT : DadoTicketIPT ; flows : Ticket from dtDTOPT to dtDTIPT } connector def DadoTicketInspecCN { participants : ~ tDTIInspOPT : TicketOPT ; ~ tDTIInspIPT : TicketIPT ; ~ tDTIResultIPT : TicketIPT ; ~ tDTIResultOPT : TicketOPT ; flows : Ticket from tDTIInspOPT to tDTIInspIPT Ticket from tDTIResultOPT to tDTIResultIPT } connector def PagamentoCN { participants : ~ pPOPT : PagamentoOPT ; ~ pPIPT : PagamentoIPT ; flows : Pagamento from pPOPT to pPIPT } } package ParkingSystemComponents { import ParkingSystemConnectors ; import ParkingSystemPorts ; import SysADL.types ; component def SistemaDeEstacionamentoCP {  configuration { components :                      CancelaCP : CancelaCP { using ports : cIPT : CancelaIPT ; } AcionarCancelaCP : AcionarCancelaCP { using ports : accOPT : CancelaOPT ; }  SensorDePassagemCP : SensorDePassagemCP { using ports : pSPasOPT : PassagemOPT ; } SensorDePresencaCP : SensorDePresencaCP { using ports : spSPreOPT : SituacaoPresencaOPT ; } InterfaceDeVagasCP : InterfaceDeVagasCP { using ports : qvIPT : QuantidadeDeVagasIPT ; }  SistemaDeVagaCP : SistemaDeVagaCP { using ports : sPreSVIPT : SituacaoPresencaIPT ; qvSVOPT : QuantidadeDeVagasOPT ; lSVOPT : LotacaoOPT ; } SistemaCancelaCP : SistemaCancelaCP { using ports : pSCIPT : PassagemIPT ; cSCOPT : CancelaOPT ; cSCIPT : CancelaIPT ; }  BotaoEntradaCP : BotaoEntradaCP { using ports : sBEOPT : SolicitarOPT ; } ImpressoraTicketCP : ImpressoraTicketCP { using ports : tITIPT : TicketIPT ; } EscanerTicketCP : EscanerTicketCP { using ports : tETOPT : TicketOPT ; } BlackboardTicketCP : BlackboardTicketCP { using ports : iBT : InspecionarKSCPT ; tBT : TicketIPT ; } SistemaTicketCP : SistemaTicketCP { using ports : lCTIPT : LotacaoIPT ; tCTOPT : TicketOPT ; tCTIPT : TicketIPT ; cCTOPT : CancelaOPT ; sSTIPT : SolicitarIPT ; iSTCPT : InspecionarCPT ; }  ControleValorCP : ControleValorCP { using ports : tCVOPT : TicketOPT ; tCVIPT : TicketIPT ; } VerificadorTicketPGCP : VerificadorTicketPGCP { using ports : tVTOPT : TicketOPT ; } MaquinaPagamentoCP : MaquinaPagamentoCP { using ports : epIPT : ErroPagamentoIPT ; tMPIPT : TicketIPT ; pMPOPT : PagamentoOPT ; } SistemaPagamentoCP : SistemaPagamentoCP { using ports : tSPOPT : TicketOPT ; pSPIPT : PagamentoIPT ; EPSPOPT : ErroPagamentoOPT ; } connectors : ACacC : AcionarCancelaCN bindings accOPT = cIPT ;     dpSPreSV : DetectarPresencaCN bindings spSPreOPT = sPreSVIPT ; mvSVIV : MonitorarVagasCN bindings qvSVOPT = qvIPT ; dPasSPSC : DetectarPassagemCN bindings pSPasOPT = pSCIPT ; acSCC : AcionarCancelaCN bindings cSCOPT = cIPT ;      sBEST : SolicitacaoCN bindings sBEOPT = sSTIPT ; tETST : TicketCN bindings tETOPT = tCTIPT ; acSTSC : AcionarCancelaCN bindings cCTOPT = cSCIPT ; lSVST : LotacaoCN bindings lSVOPT = lCTIPT ; tSTIT : TicketCN bindings tCTOPT = tITIPT ; dtiBTST : DadoTicketInspecCN bindings iBT = iSTCPT ; tSTBT : TicketCN bindings tCTOPT = tBT ; tVTpgCV : TicketCN bindings tVTOPT = tCVIPT ; tCVMP : TicketCN bindings tCVOPT = tMPIPT ;  pMPSP : PagamentoCN bindings pMPOPT = pSPIPT ; tSPBT : TicketCN bindings tSPOPT = tBT ; epSPMP : ErroPagamentoCN bindings EPSPOPT = epIPT ; } }
	component def SensorDePresencaCP { ports :   spSPreOPT : SituacaoPresencaOPT ; }
	component def CancelaCP { ports : cIPT : CancelaIPT ; }
	component def MaquinaPagamentoCP { ports :    epIPT : ErroPagamentoIPT ; tMPIPT : TicketIPT ; pMPOPT : PagamentoOPT ; }
	component def InterfaceDeVagasCP { ports : qvIPT : QuantidadeDeVagasIPT ; }
	component def AcionarCancelaCP { ports : accOPT : CancelaOPT ; }
	component def SensorDePassagemCP { ports :   pSPasOPT : PassagemOPT ; } component def ImpressoraTicketCP { ports :  tITIPT : TicketIPT ; } component def EscanerTicketCP { ports : tETOPT : TicketOPT ; }
	component def ControleVagasCP { ports : preCVIPT : PresencaIPT ; qvCVOPT : QuantidadeDeVagasOPT ; lCVOPT : LotacaoOPT ; }
	component def SistemaTicketCP { ports : lCTIPT : LotacaoIPT ; tCTOPT : TicketOPT ; tCTIPT : TicketIPT ; cCTOPT : CancelaOPT ; sSTIPT : SolicitarIPT ; iSTCPT : InspecionarCPT ; configuration { components :   ControleEntradaCP : ControleEntradaCP { using ports : lCEIPT : LotacaoIPT ; sCEIPT : SolicitarIPT ; tCEOPT : TicketOPT ; cCEOPT : CancelaOPT ; } ControleSaidaCP : ControleSaidaCP { using ports : tCSIPT : TicketIPT ; cCSOPT : CancelaOPT ; dtCSOPT : DadoTicketOPT ; dtCSIPT : DadoTicketIPT ; } delegations :      lCEIPT to lCTIPT sCEIPT to sSTIPT cCEOPT to cCTOPT tCEOPT to tCTOPT dtCSIPT to inspecaoIPT dtCSOPT to ResultadoOPT tCSIPT to tCTIPT cCSOPT to cCTOPT } } activity def CalcularValorTicketAC ( ticket : Ticket ) ( horaAtual : Hora ) ( tempoTolerancia : Int ) ( razaoPHora : Int ) : ( ticketResult : Ticket ) { body { actions : CalcularValorTicketAN : CalcularValorTicketAN { using pins : ticket : Ticket ; horaAtual : Hora ; tempoTolerancia : Int ; razaoPHora : Int ; }  delegate  ticket to ticket  delegate  horaAtual to horaAtual  delegate  tempoTolerancia to tempoTolerancia delegate razaoPHora to razaoPHora delegate ticketResult to CalcularValorTicketAN } } action def CalcularValorTicketAN ( ticket : Ticket , horaAtual : Hora , tempoTolerancia : Int , razaoPHora : Int ) : Real { constraint : post-condition CalcularValorTicketEQ delegate razaoPHora to razaoPHora delegate tempoTolerancia to tempoTolerancia delegate horaAtual to horaAtual delegate ticket to ticket delegate CalcularValorTicketAN to valorTotal } constraint CalcularValorTicketEQ ( ticket : Ticket , horaAtual : Hora , tempoTolerancia : Int , razaoPHora : Int ) : ( valorTotal : Real ) { equation = (horaAtual - ticket->entrada < tempoTolerancia) ? ticket->valor == 0 : ticket->valor == 10 + (horaAtual - ticket->entrada)/60 * razaoPHora} component def ControleFalhasPreCP { ports :   preCFOPT : PresencaOPT ; pCFPreIPT : PresencaIPT ; sCFPreIPT : StatusIPT ; } component def ControleFalhasPasCP { ports : cCFPasOPT : CancelaOPT ;  cCFPasIPT : CancelaIPT ; sCFPasIPT : StatusIPT ; } activity def ChecarSensorPassagemAC ( statusSensorPassagem : Boolean ) ( comandoIn : ComandoCancela ) : ( comandoResult : ComandoCancela ) { body { actions : ConverterPassagemAN : ChecarSensorPassagemAN { using pins : status : Boolean ; comando : ComandoCancela ; } delegate comandoIn to comando delegate statusSensorPassagem to status delegate comandoResult to ConverterPassagemAN } } action def ChecarSensorPassagemAN ( status : Boolean , comando : ComandoCancela ) : ComandoCancela { constraint : post-condition VerificarStatusPassagemEQ delegate comando to comandoC delegate status to statusSensor delegate ChecarSensorPassagemAN to comandoR } constraint VerificarStatusPassagemEQ ( comandoC : ComandoCancela , statusSensor : Boolean ) : ( comandoR : ComandoCancela ) { equation = (statusSensor ? comandoR == comandoC : comandoR == ComandoCancela::Manter )} component def SistemaDeVagaCP { ports : sPreSVIPT : SituacaoPresencaIPT ; qvSVOPT : QuantidadeDeVagasOPT ; lSVOPT : LotacaoOPT ; configuration { components :   ControleVagasCP : ControleVagasCP { using ports : preCVIPT : PresencaIPT ; qvCVOPT : QuantidadeDeVagasOPT ; lCVOPT : LotacaoOPT ; } ControleFalhasPreCP : ControleFalhasPreCP { using ports : preCFOPT : PresencaOPT ; pCFPreIPT : PresencaIPT ; sCFPreIPT : StatusIPT ; } connectors :   pCFPreCV : PresencaCN bindings preCFOPT = preCVIPT ; delegations :    lCVOPT to lSVOPT qvCVOPT to qvSVOPT  pCFPreIPT to presenca sCFPreIPT to status } } activity def ChecarSensorPresencaAC ( presenca : PresencaVaga ) ( statusSensorPresenca : Boolean ) : ( presencaResult : PresencaVaga ) { body { actions : ChecarSensorPresencaAN : ChecarSensorPresencaAN { using pins : presenca : PresencaVaga ; status : Boolean ; } delegate statusSensorPresenca to status delegate presenca to presenca delegate presencaResult to ChecarSensorPresencaAN } } action def ChecarSensorPresencaAN ( presenca : PresencaVaga , status : Boolean ) : PresencaVaga { constraint : post-condition VerificarStatusPresencaEQ delegate presenca to presenca delegate status to status delegate ChecarSensorPresencaAN to presencaResult } constraint VerificarStatusPresencaEQ ( presenca : PresencaVaga , status : Boolean ) : ( presencaResult : PresencaVaga ) { equation = status ? presencaResult == presenca : presencaResult == StatusPresenca::Desabilitado} activity def CalcularVagasAC ( dadosPresenca : PresencaVaga ) : ( vagas : VagasDisponiveis , statusLotacao : Lotacao ) { body { actions : CalcularVagasAN : CalcularVagasAN { using pins : presenca : PresencaVaga ; } ChecarLotacaoAN : ChecarLotacaoAN { using pins : vagas : VagasDisponiveis ; } delegate dadosPresenca to presenca flow from CalcularVagasAN to vagas delegate vagas to CalcularVagasAN delegate statusLotacao to ChecarLotacaoAN } } action def CalcularVagasAN ( presenca : PresencaVaga ) : VagasDisponiveis { constraint : post-condition CalcularVagasEQ delegate presenca to presenca delegate CalcularVagasAN to vagas } constraint CalcularVagasEQ ( presenca : PresencaVaga ) : ( vagas : VagasDisponiveis ) { equation =  (presenca->tipo == vagas->tipo) ? presenca->status == StatusPresenca::Desocupado ?  vagas->quantidade == vagas->quantidade + 1 : vagas->quantidade == vagas->quantidade - 1 : vagas} action def ChecarLotacaoAN ( vagas : VagasDisponiveis ) : Lotacao { constraint : post-condition VerificarLotacaoEQ delegate vagas to vagas delegate ChecarLotacaoAN to statusLotacao } constraint VerificarLotacaoEQ ( vagas : VagasDisponiveis ) : ( statusLotacao : Lotacao ) { equation = (vagas->quantidade == 0) ? statusLotacao == Lotacao::Lotado : statusLotacao == Lotacao::Vago } component def SistemaCancelaCP { ports : pSCIPT : PassagemIPT ; cSCOPT : CancelaOPT ; cSCIPT : CancelaIPT ; configuration { components :  ControleCancelaCP : ControleCancelaCP { using ports : cCCIPT : CancelaIPT ; cCCOPT : CancelaOPT ; } ControleFalhasPasCP : ControleFalhasPasCP { using ports : cCFPasOPT : CancelaOPT ; cCFPasIPT : CancelaIPT ; sCFPasIPT : StatusIPT ; } connectors :  acCFPasCC : AcionarCancelaCN bindings cCFPasOPT = cCCIPT ; delegations :  cCCIPT to cSCIPT cCCOPT to cSCOPT sCFPasIPT to status cCFPasIPT to cancela } }
	component def ControleCancelaCP { ports : cCCIPT : CancelaIPT ; cCCOPT : CancelaOPT ; }
	component def BotaoEntradaCP { ports : sBEOPT : SolicitarOPT ; }
	component def ControleEntradaCP { ports : lCEIPT : LotacaoIPT ; sCEIPT : SolicitarIPT ; tCEOPT : TicketOPT ; cCEOPT : CancelaOPT ; }
	component def ControleSaidaCP { ports : tCSIPT : TicketIPT ; cCSOPT : CancelaOPT ; dtCSOPT : DadoTicketOPT ; dtCSIPT : DadoTicketIPT ; } activity def ChecarEntradaAC ( lotacao : Lotacao ) ( solicitacao : Boolean ) : ( ticket : Ticket , comando : ComandoCancela ) { body { actions : ChecarEntradaAN : CriacaoTicketAN { using pins : lotacao : Lotacao ; solicitacao : Boolean ; } AcionarCancelaEntradaAN : AcionarCancelaEntradaAN { using pins : ticket : Ticket ; } delegate solicitacao to solicitacao delegate lotacao to lotacao flow from ChecarEntradaAN to ticket delegate ticket to ChecarEntradaAN delegate comando to AcionarCancelaEntradaAN } } action def CriacaoTicketAN ( lotacao : Lotacao , solicitacao : Boolean ) : Ticket { constraint : post-condition VerificarEntradaEQ delegate solicitacao to solicitacao delegate lotacao to lotacao delegate CriacaoTicketAN to ticket } constraint VerificarEntradaEQ ( lotacao : Lotacao , solicitacao : Boolean ) : ( ticket : Ticket ) { equation = (lotacao == Lotacao::Vago & solicitacao) ? ticket == new Ticket : ticket == null } activity def ConfirmarPagamentoAC ( ticket : Ticket ) : ( comando : ComandoCancela ) { body { actions : ConfirmarPagamentoAN : ConfirmarPagamentoAN { using pins : ticket : Ticket ; } delegate ticket to ticket delegate comando to ConfirmarPagamentoAN } } action def ConfirmarPagamentoAN ( ticket : Ticket ) : ComandoCancela { constraint : post-condition VerificarPagamentoEQ delegate ticket to ticket delegate ConfirmarPagamentoAN to comando } constraint VerificarPagamentoEQ ( ticket : Ticket ) : ( comando : ComandoCancela ) { equation = (ticket->pago) ? comando == ComandoCancela::Abrir : comando == ComandoCancela::Manter } action def AcionarCancelaEntradaAN ( ticket : Ticket ) : ComandoCancela { constraint : post-condition AtribuirEntradaEQ delegate ticket to ticketIn delegate AcionarCancelaEntradaAN to comando } constraint AtribuirEntradaEQ ( ticketIn : Ticket ) : ( comando : ComandoCancela ) { equation = (ticketIn == null) ? comando == ComandoCancela::Manter : comando == ComandoCancela::Abrir } component def BlackboardTicketCP { ports : iBT : InspecionarKSCPT ; tBT : TicketIPT ; }
	component def SistemaPagamentoCP { ports :  tSPOPT : TicketOPT ; pSPIPT : PagamentoIPT ; EPSPOPT : ErroPagamentoOPT ; }
	component def ControleValorCP { ports : tCVOPT : TicketOPT ; tCVIPT : TicketIPT ; }
	component def VerificadorTicketPGCP { ports : tVTOPT : TicketOPT ; } } package ParkingSystemPorts { import SysADL.types ;   port def PresencaOPT { flow out PresencaVaga } port def PresencaIPT { flow in PresencaVaga }   port def CancelaIPT { flow in ComandoCancela } port def CancelaOPT { flow out ComandoCancela }       port def QuantidadeDeVagasIPT { flow in VagasDisponiveis } port def QuantidadeDeVagasOPT { flow out VagasDisponiveis }   port def TicketIPT { flow in Ticket } port def TicketOPT { flow out Ticket } port def ErroPagamentoIPT { flow in Boolean } port def ErroPagamentoOPT { flow out Boolean } port def StatusIPT { flow in Boolean } port def StatusOPT { flow out Boolean } port def PassagemOPT { ports : cancela : CancelaOPT ; status : StatusOPT ; } port def PassagemIPT { ports : cancela : CancelaIPT ; status : StatusIPT ; } port def SituacaoPresencaIPT { ports : presenca : PresencaIPT ; status : StatusIPT ; } port def SituacaoPresencaOPT { ports : presenca : PresencaOPT ; status : StatusOPT ; } port def LotacaoIPT { flow in Lotacao } port def LotacaoOPT { flow out Lotacao } port def SolicitarIPT { flow in Boolean } port def SolicitarOPT { flow out Boolean } port def InspecionarCPT { ports : inspecaoIPT : DadoTicketIPT ; ResultadoOPT : DadoTicketOPT ; } port def InspecionarKSCPT { ports : ResultadoIPT : DadoTicketIPT ; InspecaoOPT : DadoTicketOPT ; } port def DadoTicketIPT { flow in Ticket } port def DadoTicketOPT { flow out Ticket } port def PagamentoIPT { flow in Pagamento } port def PagamentoOPT { flow out Pagamento } } Requirement ControlarCancelaRF ( 1 ) { text = "O sistema deve ser capaz de controlar a cancela."  Requirement ControlarCancelaAutomaticamenteRF ( 1.2 ) { text = "O sistema deve ser capaz de acionar a cancela."   derive EscanearTicketRF , FornecerTicketRF ; } Requirement ControlarCancelaManualmenteRF ( 1.1 ) { text = "O sistema deve permitir que um usuário autorizado acione a cancela manualmente." derive FecharCancelaRF , AbrirCancelaRF ; } } Requirement CapturarHorarioTicketRF ( 1.2.2 ) { text = "O sistema deve capturar o horário em que o ticket foi retirado." derive CalcularValorDoTicketRF ; } Requirement ExibirVagasRF ( 2.1 ) { text = "O sistema deve ser capaz de exibir a quantidade de vagas disponíveis de cada tipo." } Requirement MonitorarPresencaDeVeiculoRF ( 2.3 ) { text = "O sistema deve monitorar se há veículo em cada vaga."  derive InformarPresencaDeVeiculoRF ; } Requirement VerificarStatusDoTicketRF ( 1.2.6 ) { text = "O sistema deve ser capaz de verificar os status do ticket." derive ConfirmarPamentoTicketRF ; } Requirement PagarTicketRF ( 1.2.4 ) { text = "O sistema deve permitir que o usuário pague o ticket." } Requirement CalcularValorDoTicketRF ( 1.2.3 ) { text = "O sistema deve calcular o valor total do ticket com base na hora de entrada e saída." derive PagarTicketRF ; } Requirement ConfirmarPamentoTicketRF ( 1.2.7 ) { text = "O sistema deve informar se o ticket está pago." derive AbrirCancelaRF ; } Requirement VerificarPassagemVeiculoRF ( 1.1.3 ) { text = "O sistema deve ser capaz de verificar se o veículo já passou pela cancela." derive FecharCancelaRF ; } Requirement InformarPresencaDeVeiculoRF ( 2.2 ) { text = "O sistema deve informar a presença de veículo na vaga." derive GerenciarVagasRF ; } Requirement GerenciarVagasRF ( 2 ) { text = "O sistema deve gerenciar a quantidade de vagas livres e ocupadas." derive ExibirVagasRF ; } Requirement AbrirCancelaRF ( 1.1.1 ) { text = "O sistema deve abrir a cancela." derive VerificarPassagemVeiculoRF ; } Requirement FecharCancelaRF ( 1.1.2 ) { text = "O sistema deve fechar a cancela." } Requirement EscanearTicketRF ( 1.2.5 ) { text = "O sistema deve escanear o ticket." derive VerificarStatusDoTicketRF ; } Requirement FornecerTicketRF ( 1.2.1 ) { text = "O sistema deve fornecer ao usuário um ticket de acesso." derive CapturarHorarioTicketRF , AbrirCancelaRF ; } Requirement QualidadeRNF ( 3 ) { text = "O sistema deve apresentar qualidade no seu funcionamento." Requirement DisponibilidadeRNF ( 3.1 ) { text = "O sistema deve operar 24 horas por dia, 7 dias por semana." } Requirement DesempenhoRNF ( 3.2 ) { text = "O sistema deve ser capaz de processar multiplos processos ao mesmo tempo de forma eficiente." } Requirement EscalabilidadeRNF ( 3.3 ) { text = "O sistema deve ser capaz de suportar um aumento do usabilidade sem comprometer o desempenho." } Requirement SegurancaRNF ( 3.4 ) { text = "O sistema deve manipular as informações de forma criptografada para não comprometer os dados de usuários." } Requirement UsabilidadeRNF ( 3.5 ) { text = "O sistema deve ser de fácil compreensão a todo tipo de usuário." } Requirement ManutenibilidadeRNF ( 3.6 ) { text = "O sistema deve ser de fácil manutenção." } Requirement ToleranciaAFalhasRNF ( 3.7 ) { text = "O sistema deve ser tolerante a falhas no funcionamento de seus sensores." } Requirement ModificabilidadeRNF ( 3.8 ) { text = "O sistema deve ser de fácil alteração em suas funcionalidades." } }